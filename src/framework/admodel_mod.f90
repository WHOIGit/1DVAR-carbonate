!----------------------------------------------------------------------------
!     CVS:$Id: admodel_mod.F90,v 1.14 2005/02/16 15:27:40 duse Exp $
!     CVS:$Name:  $
!----------------------------------------------------------------------------

module admodel_mod
  !-------------------------------------------------------------------------
  ! Adjoint code (beginning in ad*) adapted from routines generated by the
  ! Tangent linear and Adjoint Model Compiler,  TAMC 5.3.2 and
  ! modified by Jeff Dusenberry
  !
  ! Supplemental routines (not beginning in ad*) written by Jeff Dusenberry
  !-------------------------------------------------------------------------
  implicit none

contains
  
! subroutine for use with n1qn3
  subroutine simul(indic,n,optparams,fcost,adoptparams,izs,rzs,dzs)
    use const, only : c0,c1
    use eco_params, only : nparams_opt
    use model_mod, only : model

    implicit none

    !-------------------------------------------------------------------------
    ! Arguments
    !-------------------------------------------------------------------------

    ! indic          ==1 does anything but change args (e.g. prints info, etc)
    !                ==4 normal processing
    ! n              size of problem (# parameters)
    integer, intent(inout) :: indic
    integer, intent(in) :: n

    ! bioparams      point in parameter space
    ! adbioparams    value of gradient of fcost at the point bioparams
    ! note: dimension sizes are explicit here to avoid segfault with
    ! intel compiler (JAD)
    double precision, dimension(nparams_opt), intent(in) :: optparams
    double precision, dimension(nparams_opt), intent(out) :: adoptparams

    ! fcost          value of cost function at point x
    double precision, intent(out) :: fcost

    ! working areas - not used 
    integer, dimension(*) :: izs
    double precision, dimension(*) :: rzs
    double precision, dimension(*) :: dzs

    !-------------------------------------------------------------------------
    ! Local variables
    !-------------------------------------------------------------------------
    double precision :: adfcost

    if (indic == 1) then
       ! currently doing nothing here
    else if (indic == 4) then

       ! determine gradient in cost function
       adoptparams = c0
       adfcost = c1
       call admodel(optparams,fcost,adoptparams,adfcost)


       !write(6,*) 'simul: norm of g ', &
       !     sqrt(dot_product(adoptparams,adoptparams))


       if (fcost .ge. c0) then
          if (fcost .gt. 1e32) then
             ! reject summarily
             indic = -1
          end if
       else
          indic = -1
       end if

    else
       write(6,*) 'ERROR - unexpected value of indic = ', indic
    endif

  end subroutine simul



  subroutine admodel(optparams,fcost,adoptparams,adfcost)
    use adcost, only : adcalccost
    use adeco_derivs, only : adget_costpred
    use common_mod, only : bio0,nsite,ioflag,setup_common,nt_max,nz_max
    use const, only : c0
    use cost, only : ncnsv,ncnsv_sed,ndat_max,calccost,setup_cost
    use eco_derivs, only : setup_bio
    use eco_params, only : nparams_bio,numdiagvar,numstatevar
    use grid, only : delt,nz,nt,setup_grid,ntsout
    use io, only : param_un
    use eco_derivs, only : get_costpred
    use eco_params, only : nparams_opt
    use forcing, only : setup_forcing
    use model_mod, only : opt_to_bio,ts_integrate,ts_final
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision :: fcost,adfcost
    double precision, dimension(:) ::  optparams,adoptparams

    !==============================================
    ! define local variables
    !==============================================
    double precision adbio_next(nz_max+1,numstatevar)
    double precision adbio_prev(nz_max+1,numstatevar)
    double precision adbio_temp(nz_max+1,numstatevar)
    double precision adbioparams(nparams_bio)
    double precision adcpred(ncnsv,nt_max)
    double precision adcsed_pred(ncnsv_sed,ndat_max)
    double precision addiag_next(nz_max,numdiagvar)
    double precision addiag_prev(nz_max,numdiagvar)
    double precision addiag_temp(nz_max,numdiagvar)
    double precision, dimension(nsite) :: fcost_loc,adfcost_loc
    double precision bio_next(nz_max+1,numstatevar)
    double precision bio_prev(nz_max+1,numstatevar)
    double precision bio_temp(nz_max+1,numstatevar)
    double precision bioparams(nparams_bio)
    double precision cpred(ncnsv,nt_max)
    double precision csed_pred(ncnsv_sed,ndat_max)
    double precision, dimension(nz_max,numdiagvar) :: diag_prev,diag_next,diag_temp
    double precision, dimension(:,:,:), allocatable :: bio, diag, adbio, addiag
    integer istep,isite,iout
    
!    integer :: ispin

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    adbio_next = c0
    adbio_prev = c0
    adbioparams = c0
    adcpred = c0
    adcsed_pred = c0
    addiag_next = c0
    addiag_prev = c0
    adfcost_loc = c0



    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    !----------------------------------------------
    ! FUNCTION AND TAPE COMPUTATIONS
    !----------------------------------------------
    call opt_to_bio( optparams,bioparams )
    if (ioflag) then   !Luo
          write(param_un,'(100(1x,1PG16.8,:))') bioparams
    end if

    !----------------------------------------------
    ! ADJOINT COMPUTATIONS
    !----------------------------------------------
    adfcost_loc = adfcost_loc+adfcost
    adfcost = c0
    do isite = nsite, 1, -1
       call setup_grid( isite )
       call setup_common(isite)
       call setup_forcing( isite )
       call setup_bio( isite )
       call setup_cost( isite )
       
       allocate(bio(nz+1,NumStateVar,nt))
       allocate(diag(nz,NumDiagVar,nt))
       allocate(adbio(nz+1,NumStateVar,nt))
       allocate(addiag(nz,NumDiagVar,nt))
       
       bio(1:nz+1,:,1) = bio0
       diag(1:nz,:,1) = c0
       adbio = c0
       addiag = c0

       do istep = 2, nt
          bio_prev(1:nz+1,:) = bio(1:nz+1,:,istep-1)
          diag_prev(1:nz,:) = diag(1:nz,:,istep-1)
          call ts_integrate(istep,bio_prev(1:nz+1,:),bio_next(1:nz+1,:), &
               diag_prev(1:nz,:),diag_next(1:nz,:),bioparams)
          call ts_final( istep,bio_next(1:nz+1,:),diag_next(1:nz,:) )
          bio(1:nz+1,:,istep) = bio_next(1:nz+1,:)
          diag(1:nz,:,istep) = diag_next(1:nz,:)/delt
       end do
       call get_costpred(cpred,csed_pred,bio(1:nz+1,:,:), &
            diag(1:nz,:,:),bioparams)
       call calccost( fcost_loc(isite),cpred,csed_pred )
       call adcalccost(cpred,csed_pred,adfcost_loc(isite), &
            adcpred,adcsed_pred)
       call adget_costpred(bio(1:nz+1,:,:),diag(1:nz,:,:),bioparams, &
            adcpred,adcsed_pred,adbio(1:nz+1,:,:), &
            addiag(1:nz,:,:),adbioparams)
       do istep = nt, 2, -1
          bio_prev(1:nz+1,:) = bio(1:nz+1,:,istep-1)
          diag_prev(1:nz,:) = diag(1:nz,:,istep-1)
          addiag_next(1:nz,:) = addiag_next(1:nz,:)+addiag(1:nz,:,istep)/delt
          addiag(1:nz,:,istep) = c0
          adbio_next(1:nz+1,:) = adbio_next(1:nz+1,:)+adbio(1:nz+1,:,istep)
          adbio(1:nz+1,:,istep) = c0
          call adts_final(istep,adbio_next(1:nz+1,:),addiag_next(1:nz,:))
          call adts_integrate(istep,bio_prev(1:nz+1,:),diag_prev(1:nz,:), &
               bioparams,adbio_prev(1:nz+1,:),adbio_next(1:nz+1,:), &
               addiag_prev(1:nz,:),addiag_next(1:nz,:),adbioparams)
          addiag(1:nz,:,istep-1) = addiag(1:nz,:,istep-1)+addiag_prev(1:nz,:)
          addiag_prev(1:nz,:) = c0
          adbio(1:nz+1,:,istep-1) = adbio(1:nz+1,:,istep-1)+ &
               adbio_prev(1:nz+1,:)
          adbio_prev(1:nz+1,:) = c0
       end do

       addiag(1:nz,:,1) = c0
       adbio(1:nz+1,:,1) = c0
    end do
    call adopt_to_bio(optparams,adoptparams,adbioparams)
    fcost = sum(fcost_loc)
  end subroutine admodel

  
  subroutine adts_integrate(istep,bio_prev,diag_prev,bioparams,adbio_prev, &
       adbio_next,addiag_prev,addiag_next,adbioparams)
    use const, only : c0,p5
    use eco_params, only : numdiagvar,numstatevar
    use grid, only : delt,nz
    use eco_params, only : nparams_bio
    use model_mod, only : ts_derivs
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) :: bio_prev,diag_prev,adbio_prev, &
         adbio_next,addiag_prev,addiag_next
    double precision, dimension(:) :: bioparams,adbioparams
    integer istep

    !==============================================
    ! define local variables
    !==============================================

    ! TODO: verify no memory issues with using nz here
    double precision adbio_temp(nz+1,numstatevar)
    double precision addiag_temp(nz,numdiagvar)
    double precision addydt_bio(nz+1,numstatevar)
    double precision addydt_bio_temp(nz+1,numstatevar)
    double precision addydt_diag(nz,numdiagvar)
    double precision addydt_diag_temp(nz,numdiagvar)
    double precision bio_prevh(nz+1,numstatevar)
    double precision bio_temp(nz+1,numstatevar)
    double precision diag_temp(nz,numdiagvar)
    double precision dydt_bio(nz+1,numstatevar)
    double precision dydt_diag(nz,numdiagvar)

    !----------------------------------------------
    ! SAVE ARGUMENTS
    !----------------------------------------------
    bio_prevh = bio_prev

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    adbio_temp = c0
    addiag_temp = c0
    addydt_bio = c0
    addydt_bio_temp = c0
    addydt_diag = c0
    addydt_diag_temp = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
!    if (istep .eq. 2) then
       addydt_diag = addydt_diag+addiag_next*delt
       addiag_next = c0
       adbio_prev(1:nz,:) = adbio_prev(1:nz,:)+ &
            adbio_next(1:nz,:)
       addydt_bio(1:nz,:) = addydt_bio(1:nz,:)+ &
            adbio_next(1:nz,:)*delt
       adbio_next(1:nz,:) = c0
       call adts_derivs(istep,bio_prev,diag_prev,bioparams,adbio_prev, &
            addydt_bio,addiag_prev,addydt_diag,adbioparams)
!    else
!       call ts_derivs(istep,bio_prev,dydt_bio,diag_prev,dydt_diag,bioparams)
!       bio_temp(1:nz,:) = bio_prev(1:nz,:)+ &
!            delt*dydt_bio(1:nz,:)
!       diag_temp = dydt_diag
!       addydt_diag = addydt_diag+addiag_next*delt*p5
!       addydt_diag_temp = addydt_diag_temp+addiag_next*delt*p5
!       addiag_next = c0
!       adbio_prev(1:nz,:) = adbio_prev(1:nz,:)+ &
!            adbio_next(1:nz,:)
!       addydt_bio(1:nz,:) = addydt_bio(1:nz,:)+ &
!            adbio_next(1:nz,:)*delt*p5
!       addydt_bio_temp(1:nz,:) = addydt_bio_temp(1:nz,:)+ &
!            adbio_next(1:nz,:)*delt*p5
!       adbio_next(1:nz,:) = c0
!       call adts_derivs(istep,bio_temp,diag_temp,bioparams,adbio_temp, &
!            addydt_bio_temp,addiag_temp,addydt_diag_temp,adbioparams)
!       addydt_diag = addydt_diag+addiag_temp
!       addiag_temp = c0
!       adbio_prev(1:nz,:) = adbio_prev(1:nz,:)+ &
!            adbio_temp(1:nz,:)
!       addydt_bio(1:nz,:) = addydt_bio(1:nz,:)+ &
!            adbio_temp(1:nz,:)*delt
!       adbio_temp(1:nz,:) = c0
!       bio_prev = bio_prevh
!       call adts_derivs(istep,bio_prev,diag_prev,bioparams,adbio_prev, &
!            addydt_bio,addiag_prev,addydt_diag,adbioparams)
!    endif

  end subroutine adts_integrate


  subroutine adts_derivs(istep,bio_prev,diag_prev,bioparams,adbio_prev, &
       addydt_bio,addiag_prev,addydt_diag,adbioparams)
    use adeco_derivs, only : adbioderivs,adbioderivs_init
    use adphysderivs_mod, only : adphysderivs,adphysderivs_init
    use const, only : c0
    use eco_derivs, only : bioderivs_init
    use eco_params, only : numstatevar
    use grid, only : nz
    use eco_params, only : nparams_bio,numdiagvar
    use physderivs_mod, only : physderivs_init
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) ::  adbio_prev,addydt_bio, &
         diag_prev,addiag_prev,addydt_diag,bio_prev
    double precision, dimension(:) :: adbioparams,bioparams
    integer istep
    

    !==============================================
    ! define local variables
    !==============================================
    double precision addydt_phys(nz+1,numstatevar)
    double precision,dimension(nz) :: par,adpar
    double precision,dimension(nz+1) :: par_ifc,adpar_ifc
    double precision bio_prevh(nz+1,numstatevar)
    double precision temp

    bio_prevh = bio_prev

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    addydt_phys = c0
    adpar = c0
    adpar_ifc = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    call bioderivs_init(istep,par,par_ifc,bio_prev,diag_prev)
    call physderivs_init(istep,bio_prev)
    addydt_phys = addydt_phys+addydt_bio
    call adphysderivs(istep,bio_prev,bioparams,adbio_prev,addydt_phys,adbioparams)
    bio_prev = bio_prevh
    call adphysderivs_init(istep,bio_prev,adbio_prev)
    call adbioderivs(istep,par,par_ifc,bio_prev,bioparams,adpar,adpar_ifc, &
         adbio_prev,addydt_bio,addydt_diag,adbioparams)
    call adbioderivs_init(istep,bio_prev,diag_prev,adpar,adpar_ifc, &
         adbio_prev,addiag_prev)

  end subroutine adts_derivs



  subroutine adts_final(istep,adbio_next,addiag_next)
    use const, only : c0
    use eco_params, only : numstatevar
    use forcing, only : dml
    use grid, only : dzt,nz,zifc
    use eco_params, only : numdiagvar
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) ::  adbio_next,addiag_next
    integer :: istep

    !==============================================
    ! define local variables
    !==============================================
    double precision :: adds
    integer :: isv,iz,ndml

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    adds = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    ! NOTE:  TAMC failed to get the ndml dependency correct.  Added
    ! here by hand.  jdusenberry 2006-10-17

    ndml = 0
    iz = 1
    do while (dml(istep) .gt. zifc(iz+1) .and. iz .le. nz )
       ndml = iz
       iz = iz+1
    end do
    if (ndml .gt. 0) then
       do isv = 1, numstatevar
          adds = c0
          adds = adds+sum(adbio_next(1:ndml,isv))
          adbio_next(1:ndml,isv) = c0
          adds = adds/zifc(ndml+1)
          do iz = 1, ndml
             adbio_next(iz,isv) = adbio_next(iz,isv)+adds*dzt(iz)
          end do
          adds = c0
       end do
    endif

  end subroutine adts_final



  subroutine adopt_to_bio(optparams,adoptparams,adbioparams)
    use common_mod, only : bioparams0,bioparams_default
    use const, only : c0
    use eco_params, only : bio_opt_map,nparams_bio,nparams_opt
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:) ::  optparams, adbioparams,adoptparams

    !==============================================
    ! define local variables
    !==============================================
    integer :: ipar

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    do ipar = 1, nparams_opt
      if (bioparams_default(bio_opt_map(ipar)) .ne. c0) then
          adoptparams(ipar) = adoptparams(ipar)+ &
               adbioparams(bio_opt_map(ipar))* &
               bioparams_default(bio_opt_map(ipar))* &
               exp(optparams(ipar))  
          adbioparams(bio_opt_map(ipar)) = c0
       else
          adoptparams(ipar) = adoptparams(ipar)+ &
                adbioparams(bio_opt_map(ipar)) * exp(optparams(ipar))
          adbioparams(bio_opt_map(ipar)) = c0
       endif
    end do

  end subroutine adopt_to_bio


end module admodel_mod
