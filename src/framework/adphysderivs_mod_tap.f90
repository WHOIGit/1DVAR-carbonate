!----------------------------------------------------------------------------
!     CVS:$Id: adphysderivs_mod.F90,v 1.14 2005/04/28 17:34:20 duse Exp $
!     CVS:$Name:  $
!----------------------------------------------------------------------------
module adphysderivs_mod
  !-------------------------------------------------------------------------
  ! Adjoint code (beginning in ad*) adapted from routines generated by the
  ! Tangent linear and Adjoint Model Compiler,  TAMC 5.3.2 and
  ! modified by Jeff Dusenberry
  !-------------------------------------------------------------------------
  implicit none

contains

  subroutine adphysderivs(istep,bio_prev,bioparams,adbio_prev,addydt,adbioparams)
    use const, only : c0
    use eco_params, only : numstatevar
    use grid, only : nz
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) :: bio_prev,adbio_prev,addydt
    double precision, dimension(:) :: bioparams,adbioparams
    integer istep

    !==============================================
    ! define local variables
    !==============================================
    double precision addydt_tmp(nz+1,numstatevar)

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    addydt_tmp = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    addydt_tmp = addydt_tmp+addydt
    call adsink(bio_prev,bioparams,adbio_prev,addydt_tmp,adbioparams)
    addydt_tmp = addydt_tmp+addydt
    call adset_sflux( adbio_prev,addydt_tmp )
    addydt_tmp = addydt_tmp+addydt
    call advertadv(istep,bio_prev,adbio_prev,addydt_tmp)
    addydt_tmp = addydt_tmp+addydt
    call adhorizadv(istep,adbio_prev,addydt_tmp)
    addydt_tmp = addydt_tmp+addydt
    addydt = c0
    call advertmix( istep,adbio_prev,addydt_tmp )

  end subroutine adphysderivs


  subroutine adphysderivs_init(istep,bio_prev,adbio_prev)
    use common_mod, only : bbcnsv,flag_bbcnsv
    use const, only : c0,c1,c2,mc1
    use grid, only : nz
    use eco_params, only : numstatevar
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) ::  bio_prev,adbio_prev
    integer istep 
    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    where (bbcnsv(:,istep) .lt. mc1)
       bio_prev(nz+1,:) = bio_prev(nz,:)- &
            (bio_prev(nz-1,:)-bio_prev(nz,:))
       where (bio_prev(nz+1,:) .lt. c0)
          adbio_prev(nz+1,:) = c0
       endwhere
       adbio_prev(nz-1,:) = adbio_prev(nz-1,:)- &
            adbio_prev(nz+1,:)
       adbio_prev(nz,:) = adbio_prev(nz,:)+ &
            2*adbio_prev(nz+1,:)
       adbio_prev(nz+1,:) = c0
    elsewhere
       where(flag_bbcnsv(:) .eq. c1)
               bio_prev(nz+1,:)=bbcnsv(:,istep-1)
        elsewhere(flag_bbcnsv(:) .ge.c2)
               bio_prev(nz+1,:)=bio_prev(nz,:)+bbcnsv(:,istep-1)
        endwhere
       where (bio_prev(nz+1,:) .lt. c0)
          adbio_prev(nz+1,:) = c0
       endwhere
       where(flag_bbcnsv(:) .eq. c1)
           adbio_prev(nz+1,:) = c0
       elsewhere(flag_bbcnsv(:) .ge.c2)
           adbio_prev(nz,:) = adbio_prev(nz,:) +  adbio_prev(nz+1,:)
           adbio_prev(nz+1,:) = c0
       endwhere
    endwhere
    
  end subroutine adphysderivs_init


  subroutine adset_sflux(adbio_prev,addydt)
    use const, only : c0
    use eco_common, only : aeonsv
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) :: adbio_prev,addydt

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    where (aeonsv .ne. 0)
       addydt(1,:) = c0
    endwhere
    addydt = c0

  end subroutine adset_sflux


  subroutine adsink( bio_prev, bioparams,bio_prevb, dydtb, bioparamsb)
    use const, only : c0,c1,c2,rc6,secperday,p5
    use eco_common, only : wnsvflag
    use eco_params, only : numstatevar
    use grid, only : delt,nz,rdzt,rdzv
    use physderivs_mod, only : smalln
    use eco_params, only : iwnsvo
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) ::  bio_prevb,dydtb,bio_prev
    double precision, dimension(:) :: bioparams,bioparamsb

    !==============================================
    ! define local variables
    !==============================================
    INTEGER :: branch, isv, k, km1, km2, kp1
  DOUBLE PRECISION :: abs1, abs1b, abs2, abs2b, cfl, cflb, d0, d0b, d1, &
&  d1b, psi_work, psi_workb, psimrj, psimrjb, psiprj, psiprjb, rj, rjb, &
&  rjm, rjmb, rjp, rjpb, tempb, tempb0, tempb1, tempb2, tempb3, tempb4, &
&  wfld, wfldb, wflux(nz+1), wfluxb(nz+1), wfluxkp1, wfluxkp1b, wm, wmb&
&  , wnsv(numstatevar), wnsvb(numstatevar), wp, wpb
  INTRINSIC MAX, ABS, MIN
!-----------------------------------------------------------------------
! Arguments
!-----------------------------------------------------------------------
! bio_prev(nz,nsv)    state variable profiles (various units)
! dydt                time derivatives for bio_prev
!-----------------------------------------------------------------------
! Subroutine adapted from MITgcm routine.  See vertadv subroutine
! in this module for details.
!-----------------------------------------------------------------------
! loop counters and field indices
! abbreviations and flux limiters
! auxillary variable
! following added by JAD to get adjoint 
!---------------------------------------------------------------------
  wnsv = bioparams(iwnsvo)*wnsvflag
  DO isv=1,numstatevar
    CALL PUSHINTEGER4(k)
    DO k=nz+1,2,-1
! use the "right" sign: downward velocity wFld is negative, 
! if sinking (i.e., downward) velocity ws is positive 
      wfld = -(wnsv(isv)/secperday)
      IF (wfld .GE. 0.) THEN
        abs1 = wfld
        CALL PUSHINTEGER4(1)
      ELSE
        abs1 = -wfld
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(wp)
! some abbreviations
      wp = wfld + abs1
      IF (wfld .GE. 0.) THEN
        abs2 = wfld
        CALL PUSHINTEGER4(1)
      ELSE
        abs2 = -wfld
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(wm)
      wm = wfld - abs2
      IF (k + 1 .GT. nz + 1) THEN
        CALL PUSHINTEGER4(kp1)
        kp1 = nz + 1
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(kp1)
        kp1 = k + 1
        CALL PUSHINTEGER4(0)
      END IF
      IF (k - 1 .LT. 1) THEN
        CALL PUSHINTEGER4(km1)
        km1 = 1
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(km1)
        km1 = k - 1
        CALL PUSHINTEGER4(0)
      END IF
      IF (k - 2 .LT. 1) THEN
        CALL PUSHINTEGER4(km2)
        km2 = 1
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(km2)
        km2 = k - 2
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(rjp)
      rjp = bio_prev(km2, isv) - bio_prev(km1, isv)
      CALL PUSHREAL8(rj)
      rj = bio_prev(km1, isv) - bio_prev(k, isv)
      CALL PUSHREAL8(rjm)
      rjm = bio_prev(k, isv) - bio_prev(kp1, isv)
      IF (wfld*delt*rdzv(k) .GE. 0.) THEN
        CALL PUSHREAL8(cfl)
        cfl = wfld*delt*rdzv(k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHREAL8(cfl)
        cfl = -(wfld*delt*rdzv(k))
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(d0)
! DST3 parameters
      d0 = (c2-cfl)*(c1-cfl)*rc6
      CALL PUSHREAL8(d1)
      d1 = (c1-cfl*cfl)*rc6
      CALL PUSHREAL8(psiprj)
      psiprj = d0*rj + d1*rjm
      CALL PUSHREAL8(psimrj)
      psimrj = d0*rj + d1*rjp
      IF (rj .GT. c0) THEN
        IF (rj .LT. psiprj) THEN
          psiprj = rj
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        psi_work = (c1-cfl)/(smalln+cfl)*rjm
        IF (psi_work .LT. psiprj) THEN
          psiprj = psi_work
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (c0 .GT. psiprj) THEN
          psiprj = c0
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (rj .LT. psimrj) THEN
          psimrj = rj
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        psi_work = (c1-cfl)/(smalln+cfl)*rjp
        IF (psi_work .LT. psimrj) THEN
          psimrj = psi_work
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (c0 .GT. psimrj) THEN
          psimrj = c0
          CALL PUSHINTEGER4(3)
        ELSE
          CALL PUSHINTEGER4(2)
        END IF
      ELSE
        IF (rj .GT. psiprj) THEN
          psiprj = rj
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        psi_work = (c1-cfl)/(smalln+cfl)*rjm
        IF (psi_work .GT. psiprj) THEN
          psiprj = psi_work
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (c0 .LT. psiprj) THEN
          psiprj = c0
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (rj .GT. psimrj) THEN
          psimrj = rj
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        psi_work = (c1-cfl)/(smalln+cfl)*rjp
        IF (psi_work .GT. psimrj) THEN
          psimrj = psi_work
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (c0 .LT. psimrj) THEN
          psimrj = c0
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
      END IF
! sink due to sinking for layer/cell k
! minus sign because this has been moved to the right hand side
      IF (k .LE. nz) THEN
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
    END DO
    k = 1
  END DO
  wnsvb(1:numstatevar) = 0.D0
  DO isv=numstatevar,1,-1
    wfluxb(1:nz+1) = 0.D0
    wfluxkp1b = rdzt(k)*dydtb(k, isv)
    wfluxb(k) = 0.D0
    dydtb(k, isv) = 0.D0
    DO k=2,nz+1,1
      wfluxb(k) = wfluxb(k) + wfluxkp1b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        wfluxkp1b = 0.D0
      ELSE
        wfluxkp1b = rdzt(k)*dydtb(k, isv)
        wfluxb(k) = wfluxb(k) - rdzt(k)*dydtb(k, isv)
        dydtb(k, isv) = 0.D0
      END IF
      tempb3 = 0.5*wp*wfluxb(k)
      tempb4 = 0.5*wm*wfluxb(k)
      wpb = 0.5*(bio_prev(k, isv)+psiprj)*wfluxb(k)
      bio_prevb(k, isv) = bio_prevb(k, isv) + tempb3
      psiprjb = tempb3
      wmb = 0.5*(bio_prev(km1, isv)-psimrj)*wfluxb(k)
      bio_prevb(km1, isv) = bio_prevb(km1, isv) + tempb4
      psimrjb = -tempb4
      wfluxb(k) = 0.D0
      CALL POPINTEGER4(branch)
      IF (branch .LT. 2) THEN
        IF (.NOT.branch .LT. 1) psimrjb = 0.D0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          psi_workb = 0.D0
        ELSE
          psi_workb = psimrjb
          psimrjb = 0.D0
        END IF
        tempb0 = psi_workb/(smalln+cfl)
        cflb = (-((c1-cfl)*rjp/(smalln+cfl))-rjp)*tempb0
        rjpb = (c1-cfl)*tempb0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          rjb = 0.D0
        ELSE
          rjb = psimrjb
          psimrjb = 0.D0
        END IF
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) psiprjb = 0.D0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          psi_workb = 0.D0
        ELSE
          psi_workb = psiprjb
          psiprjb = 0.D0
        END IF
        tempb = psi_workb/(smalln+cfl)
        cflb = cflb + (-((c1-cfl)*rjm/(smalln+cfl))-rjm)*tempb
        rjmb = (c1-cfl)*tempb
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) THEN
          rjb = rjb + psiprjb
          psiprjb = 0.D0
        END IF
      ELSE
        IF (.NOT.branch .LT. 3) psimrjb = 0.D0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          psi_workb = 0.D0
        ELSE
          psi_workb = psimrjb
          psimrjb = 0.D0
        END IF
        tempb2 = psi_workb/(smalln+cfl)
        cflb = (-((c1-cfl)*rjp/(smalln+cfl))-rjp)*tempb2
        rjpb = (c1-cfl)*tempb2
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          rjb = 0.D0
        ELSE
          rjb = psimrjb
          psimrjb = 0.D0
        END IF
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) psiprjb = 0.D0
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          psi_workb = 0.D0
        ELSE
          psi_workb = psiprjb
          psiprjb = 0.D0
        END IF
        tempb1 = psi_workb/(smalln+cfl)
        cflb = cflb + (-((c1-cfl)*rjm/(smalln+cfl))-rjm)*tempb1
        rjmb = (c1-cfl)*tempb1
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) THEN
          rjb = rjb + psiprjb
          psiprjb = 0.D0
        END IF
      END IF
      CALL POPREAL8(psimrj)
      d0b = rj*psiprjb + rj*psimrjb
      rjb = rjb + d0*psiprjb + d0*psimrjb
      d1b = rjm*psiprjb + rjp*psimrjb
      rjpb = rjpb + d1*psimrjb
      CALL POPREAL8(psiprj)
      rjmb = rjmb + d1*psiprjb
      CALL POPREAL8(d1)
      cflb = cflb + (-(rc6*(c2-cfl))-rc6*(c1-cfl))*d0b - rc6*2*cfl*d1b
      CALL POPREAL8(d0)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(cfl)
        wfldb = -(rdzv(k)*delt*cflb)
      ELSE
        CALL POPREAL8(cfl)
        wfldb = rdzv(k)*delt*cflb
      END IF
      CALL POPREAL8(rjm)
      bio_prevb(k, isv) = bio_prevb(k, isv) + rjmb
      bio_prevb(kp1, isv) = bio_prevb(kp1, isv) - rjmb
      CALL POPREAL8(rj)
      bio_prevb(km1, isv) = bio_prevb(km1, isv) + rjb
      bio_prevb(k, isv) = bio_prevb(k, isv) - rjb
      CALL POPREAL8(rjp)
      bio_prevb(km2, isv) = bio_prevb(km2, isv) + rjpb
      bio_prevb(km1, isv) = bio_prevb(km1, isv) - rjpb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPINTEGER4(km2)
      ELSE
        CALL POPINTEGER4(km2)
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPINTEGER4(km1)
      ELSE
        CALL POPINTEGER4(km1)
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPINTEGER4(kp1)
      ELSE
        CALL POPINTEGER4(kp1)
      END IF
      CALL POPREAL8(wm)
      wfldb = wfldb + wmb
      abs2b = -wmb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        wfldb = wfldb - abs2b
      ELSE
        wfldb = wfldb + abs2b
      END IF
      CALL POPREAL8(wp)
      wfldb = wfldb + wpb
      abs1b = wpb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        wfldb = wfldb - abs1b
      ELSE
        wfldb = wfldb + abs1b
      END IF
      wnsvb(isv) = wnsvb(isv) - wfldb/secperday
    END DO
    CALL POPINTEGER4(k)
  END DO
  bioparamsb(iwnsvo) = bioparamsb(iwnsvo) + SUM(wnsvflag*wnsvb)
  dydtb(:, :) = 0.D0

  end subroutine adsink


  subroutine adhorizadv( istep, adbio_prev, addydt )
    use common_mod, only : horiz_adv,lhoriz_adv
    use const, only : c0
    use grid, only : nz
    use physderivs_mod, only : hadv_wt
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision, dimension(:,:) ::  adbio_prev, addydt
    integer istep

    !==============================================
    ! define local variables
    !==============================================
    integer iz

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    do iz = nz, 16, -1
       where (lhoriz_adv)
          adbio_prev(iz,:) = adbio_prev(iz,:)-addydt(iz,:)*hadv_wt* &
               horiz_adv(iz,:,istep)
          addydt(iz,:) = c0
       endwhere
    end do
    addydt = c0

  end subroutine adhorizadv



  subroutine advertadv( istep, bio_prev, adbio_prev, addydt )
    use const, only : c0,c1,c2,rc6,secperday,p5
    use eco_params, only : numstatevar
    use forcing, only : wvel
    use grid, only : delt,nz,rdzt,rdzv
    use physderivs_mod, only : smalln
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision adbio_prev(:,:)
    double precision addydt(:,:)
    double precision bio_prev(:,:)
    integer istep

    !==============================================
    ! define local variables
    !==============================================
    double precision adpsi_work
    double precision adpsimrj
    double precision adpsiprj
    double precision adrj
    double precision adrjm
    double precision adrjp
    double precision adwflux(nz+1)
    double precision adwfluxkp1
    double precision cfl
    double precision d0
    double precision d1
    integer isv
    integer k
    integer km1
    integer km2
    integer kp1
    double precision psi_work
    double precision psimrj
    double precision psiprj
    double precision rj
    double precision rjm
    double precision rjp
    double precision wfld
    double precision wm
    double precision wp

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    adpsi_work = c0
    adpsimrj = c0
    adpsiprj = c0
    adrj = c0
    adrjm = c0
    adrjp = c0
    adwflux = c0
    adwfluxkp1 = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    do isv = 1, numstatevar
       adpsi_work = c0
       adpsimrj = c0
       adpsiprj = c0
       adrj = c0
       adrjm = c0
       adrjp = c0
       adwfluxkp1 = c0
       do k = 1, nz+1
          wfld = -wvel(k,istep)
          wp = wfld+abs(wfld)
          wm = wfld-abs(wfld)
          kp1 = min(k+1,nz+1)
          km1 = max(k-1,1)
          km2 = max(k-2,1)
          rjp = bio_prev(km2,isv)-bio_prev(km1,isv)
          rj = bio_prev(km1,isv)-bio_prev(k,isv)
          rjm = bio_prev(k,isv)-bio_prev(kp1,isv)
          cfl = abs(wfld*delt*rdzv(k))
          d0 = (c2-cfl)*(c1-cfl)*rc6
          d1 = (c1-cfl*cfl)*rc6
          psiprj = d0*rj+d1*rjm
          psimrj = d0*rj+d1*rjp
          adwflux(k) = adwflux(k)+adwfluxkp1
          adwfluxkp1 = c0
          if (k .le. nz) then
             adbio_prev(k,isv) = adbio_prev(k,isv)+ &
                  addydt(k,isv)*(wvel(kp1,istep)-wvel(k,istep))*rdzt(k)
             adwflux(k) = adwflux(k)-addydt(k,isv)*rdzt(k)
             adwfluxkp1 = adwfluxkp1+addydt(k,isv)*rdzt(k)
             addydt(k,isv) = c0
          endif
          adbio_prev(k,isv) = adbio_prev(k,isv)+p5*adwflux(k)*wp
          adbio_prev(km1,isv) = adbio_prev(km1,isv)+p5*adwflux(k)*wm
          adpsimrj = adpsimrj-p5*adwflux(k)*wm
          adpsiprj = adpsiprj+p5*adwflux(k)*wp
          adwflux(k) = c0
          if (rj .gt. c0) then
             if (rj .lt. psiprj) then
                psiprj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjm
             if (psi_work .lt. psiprj) then
                psiprj = psi_work
             endif
             if (rj .lt. psimrj) then
                psimrj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjp
             if (psi_work .lt. psimrj) then
                psimrj = psi_work
             endif
             if (c0 .gt. psimrj) then
                adpsimrj = c0
             endif
             psimrj = d0*rj+d1*rjp
             if (rj .lt. psimrj) then
                psimrj = rj
             endif
             if (psi_work .lt. psimrj) then
                adpsi_work = adpsi_work+adpsimrj
                adpsimrj = c0
             endif
             adrjp = adrjp+adpsi_work*((c1-cfl)/(smalln+cfl))
             adpsi_work = c0
             psimrj = d0*rj+d1*rjp
             if (rj .lt. psimrj) then
                adrj = adrj+adpsimrj
                adpsimrj = c0
             endif
             if (c0 .gt. psiprj) then
                adpsiprj = c0
             endif
             psiprj = d0*rj+d1*rjm
             if (rj .lt. psiprj) then
                psiprj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjm
             if (psi_work .lt. psiprj) then
                adpsi_work = adpsi_work+adpsiprj
                adpsiprj = c0
             endif
             adrjm = adrjm+adpsi_work*((c1-cfl)/(smalln+cfl))
             adpsi_work = c0
             psiprj = d0*rj+d1*rjm
             if (rj .lt. psiprj) then
                adrj = adrj+adpsiprj
                adpsiprj = c0
             endif
          else
             if (rj .gt. psiprj) then
                psiprj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjm
             if (psi_work .gt. psiprj) then
                psiprj = psi_work
             endif
             if (rj .gt. psimrj) then
                psimrj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjp
             if (psi_work .gt. psimrj) then
                psimrj = psi_work
             endif
             if (c0 .lt. psimrj) then
                adpsimrj = c0
             endif
             psimrj = d0*rj+d1*rjp
             if (rj .gt. psimrj) then
                psimrj = rj
             endif
             if (psi_work .gt. psimrj) then
                adpsi_work = adpsi_work+adpsimrj
                adpsimrj = c0
             endif
             adrjp = adrjp+adpsi_work*((c1-cfl)/(smalln+cfl))
             adpsi_work = c0
             psimrj = d0*rj+d1*rjp
             if (rj .gt. psimrj) then
                adrj = adrj+adpsimrj
                adpsimrj = c0
             endif
             if (c0 .lt. psiprj) then
                adpsiprj = c0
             endif
             psiprj = d0*rj+d1*rjm
             if (rj .gt. psiprj) then
                psiprj = rj
             endif
             psi_work = (c1-cfl)/(smalln+cfl)*rjm
             if (psi_work .gt. psiprj) then
                adpsi_work = adpsi_work+adpsiprj
                adpsiprj = c0
             endif
             adrjm = adrjm+adpsi_work*((c1-cfl)/(smalln+cfl))
             adpsi_work = c0
             psiprj = d0*rj+d1*rjm
             if (rj .gt. psiprj) then
                adrj = adrj+adpsiprj
                adpsiprj = c0
             endif
          endif
          adrj = adrj+adpsimrj*d0
          adrjp = adrjp+adpsimrj*d1
          adpsimrj = c0
          adrj = adrj+adpsiprj*d0
          adrjm = adrjm+adpsiprj*d1
          adpsiprj = c0
          adbio_prev(k,isv) = adbio_prev(k,isv)+adrjm
          adbio_prev(kp1,isv) = adbio_prev(kp1,isv)-adrjm
          adrjm = c0
          adbio_prev(k,isv) = adbio_prev(k,isv)-adrj
          adbio_prev(km1,isv) = adbio_prev(km1,isv)+adrj
          adrj = c0
          adbio_prev(km1,isv) = adbio_prev(km1,isv)-adrjp
          adbio_prev(km2,isv) = adbio_prev(km2,isv)+adrjp
          adrjp = c0
       end do
       adwfluxkp1 = c0
       adwflux = c0
    end do
    addydt = c0

  end subroutine advertadv


  subroutine advertmix(istep,adbio_prev,addydt)
    use adnumeric_subs, only : adtridag
    use eco_params, only : numstatevar
    use const, only : c0,c1,c2,p5
    use forcing, only : rkz
    use grid, only : delt,dzt,nz,zmid
    implicit none

    !==============================================
    ! define arguments
    !==============================================
    double precision,dimension(:,:) ::  adbio_prev,addydt
    integer istep

    !==============================================
    ! define local variables
    !==============================================
    double precision adbio_new(nz)
    double precision adrr(nz)
    integer isv
    integer iz
    double precision tria(nz)
    double precision trib(nz)
    double precision tric(nz)

    !----------------------------------------------
    ! RESET LOCAL ADJOINT VARIABLES
    !----------------------------------------------
    adbio_new = c0
    adrr = c0

    !----------------------------------------------
    ! ROUTINE BODY
    !----------------------------------------------
    iz = 1
    tria(iz) = c0
    tric(iz) = -(p5*delt*rkz(iz+1,istep)/(zmid(iz+1)-zmid(iz))/dzt(iz))
    trib(iz) = c1-tric(iz)
    do iz = 2, nz
       tria(iz) = -(p5*delt*rkz(iz,istep)/(zmid(iz)-zmid(iz-1))/dzt(iz))
       tric(iz) = -(p5*delt*rkz(iz+1,istep)/(zmid(iz+1)-zmid(iz))/dzt(iz))
       trib(iz) = c1-tria(iz)-tric(iz)
    end do
    trib(nz) = c1-tria(nz)
    do isv = numstatevar, 1, -1
       do iz = 1, nz
          adbio_new(iz) = adbio_new(iz)+addydt(iz,isv)/delt
          adbio_prev(iz,isv) = adbio_prev(iz,isv)-addydt(iz,isv)/delt
          addydt(iz,isv) = c0
       end do
       call adtridag( tria,trib,tric,nz,adrr,adbio_new )
       adbio_prev(nz-1,isv) = adbio_prev(nz-1,isv)+ &
            adrr(nz)*p5*delt/(zmid(nz)-zmid(nz-1))/ &
            dzt(nz)*rkz(nz,istep)
       adbio_prev(nz+1,isv) = adbio_prev(nz+1,isv)+ &
            adrr(nz)*delt/(zmid(nz+1)-zmid(nz))/ &
            dzt(nz)*rkz(nz+1,istep)
       adbio_prev(nz,isv) = adbio_prev(nz,isv)+ &
            adrr(nz)*(1-p5*delt/(zmid(nz)-zmid(nz-1))/ &
            dzt(nz)*rkz(nz,istep)-delt/(zmid(nz+1)-zmid(nz))/ &
            dzt(nz)*rkz(nz+1,istep))
       adrr(nz) = c0
       do iz = 2, nz-1
          adbio_prev(iz-1,isv) = adbio_prev(iz-1,isv)+adrr(iz)*p5*delt/ &
               (zmid(iz)-zmid(iz-1))/dzt(iz)*rkz(iz,istep)
          adbio_prev(iz+1,isv) = adbio_prev(iz+1,isv)+adrr(iz)*p5*delt/ &
               (zmid(iz+1)-zmid(iz))/dzt(iz)*rkz(iz+1,istep)
          adbio_prev(iz,isv) = adbio_prev(iz,isv)+adrr(iz)*(1-p5*delt/ &
               (zmid(iz)-zmid(iz-1))/dzt(iz)*rkz(iz,istep)-p5*delt/ &
               (zmid(iz+1)-zmid(iz))/dzt(iz)*rkz(iz+1,istep))
          adrr(iz) = c0
       end do
       iz = 1
       adbio_prev(iz+1,isv) = adbio_prev(iz+1,isv)+adrr(iz)*p5*delt/ &
            (zmid(iz+1)-zmid(iz))/dzt(iz)*rkz(iz+1,istep)
       adbio_prev(iz,isv) = adbio_prev(iz,isv)+adrr(iz)*(1-p5*delt/ &
            (zmid(iz+1)-zmid(iz))/dzt(iz)*rkz(iz+1,istep))
       adrr(iz) = c0
    end do

  end subroutine advertmix


end module adphysderivs_mod
